***认识生产者/消费者模式
生产者/消费者问题是一个多线程同步问题的经典案例。这玩意在很多开发领域都能派上用场，
于是也被总结为生产者/消费者模式。什么是生产者/消费者问题，下面我们场景重现：某个模块
负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、
进程等）。产生数据的模块，就形象的称为生产者，而处理数据的模块，就称为消费者。 单单抽象
出生产者和消费者，还够不上是生产者／消费者模式。该模式还需要有一个缓冲区处于生产者和消
费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。

为了不至于太抽象，我们举个寄信的例子（虽说这年头寄信已经不时兴，但这个例子还是比较贴切的）。
假设你要寄一封平信，大致过程如下：
1、你把信写好——相当于生产者制造数据
2、你把信放入邮筒——相当于生产者把数据放入缓冲区
3、邮递员把信从邮筒取出——相当于消费者把数据取出缓冲区
4、邮递员把信拿去邮局做相应的处理——相当于消费者处理数据

那么，这个缓冲区有什么用捏？为什么不让生产者直接调用消费者的某个函数，直接把数据传递
过去？搞出这么一个缓冲区作甚？？？
其实这里面是大有讲究的，大概有如下一些好处:
1、更加解耦，降低依赖成本
假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费
者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两
者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。

接着上述的例子，如果不使用邮筒（也就是缓冲区），你必须得把信直接交给邮递员。有同学会说，
直接给邮递员不是挺简单的嘛？其实不简单，你必须得认识谁是邮递员，才能把信给他（光凭身上
穿的制服，万一有人假冒，就惨了）。这就产生和你和邮递员之间的依赖（相当于生产者和消费者
的强耦合）。万一哪天邮递员换人了，你还要重新认识一下（相当于消费者变化导致修改生产者代
码）。而邮筒相对来说比较固定，你依赖它的成本就比较低（相当于和缓冲区之间的弱耦合）。

2、支持并发
生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），
在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者就
会白白糟蹋大好时光。使用了生产者／消费者模式之后，生产者和消费者可以是两个独立的并发
主体。生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据。基本上不用依赖
消费者的处理速度。其实当初这个模式，主要就是用来处理并发问题的。

3、支持忙闲不均
缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造
快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，
消费者再慢慢处理掉。实质上还是并发的好处，有了并发，两边可以各自独立。


