**同步阻塞模型

*其核心代码如下：
bind(srvfd);
listen(srvfd);
for(;;){
    // 即循环的进行accept调用，逐个的处理内核已完成链接队列中的tcp链接
    clifd = accept(srvfd,...); //开始接受客户端来的连接
    read(clifd,buf,...);       //从客户端读取数据
    dosomthingonbuf(buf);  
    write(clifd,buf)          //发送数据到客户端
}

**缺点：
1、如果没有客户端的连接请求，进程会阻塞在accept系统调用处，程序不能执行其他任何操作。
2、在与客户端建立好一条链路后，通过read系统调用从客户端接受数据，而客户端何时发送数
   据过来是不可控的。如果客户端迟迟不发生数据过来，则程序同样会阻塞在read调用，此时，
   如果另外的客户端来尝试连接时，都会失败。
3、同样的道理，write系统调用也会使得程序出现阻塞(例如：客户端接受数据异常缓慢，导致
   写缓冲区满，数据迟迟发送不出)。
