**多线程并发
在多进程并发模型中，每一个客户端连接开启fork一个进程，虽然linux中引入了写
实拷贝机制，大大降低了fork一个子进程的消耗，但若客户端连接较大，则系统依
然将不堪负重。通过多线程(或线程池)并发模型，可以在一定程度上改善这一问题.
此处不仅仅是简单的将进程替换为线程，具体到线程，还可以有不同的线程模型。如下：

在服务端的线程模型实现方式一般有三种：
（1）按需生成(来一个连接生成一个线程)
（2）线程池(预先生成很多线程)
（3）Leader follower（LF）  // 这种方式的具体实现是什么呢？？？

**为简单起见，以第一种为例，其核心代码如下：
void *thread_callback( void *args ) //线程回调函数
{
    int clifd = *(int *)args ;
    client_handler(clifd);
}
//===============================================================
void client_handler(clifd){
    read(clifd,buf,...);       //从客户端读取数据
    dosomthingonbuf(buf);  
    write(clifd,buf)          //发送数据到客户端
}
//===============================================================
bind(srvfd);
listen(srvfd);
for(;;){
    clifd = accept();
    pthread_create(...,thread_callback,&clifd);
}

服务端分为主线程和工作线程，主线程负责accept()连接，而工作线程负责处理
业务逻辑和流的读取等。因此，即使在工作线程阻塞的情况下，也只是阻塞在线
程范围内，对继续接受新的客户端连接不会有影响。

第二种实现方式，通过线程池的引入可以避免频繁的创建、销毁线程，能在很大
程序上提升性能。但不管如何实现，多线程模型先天具有如下缺点：
1）稳定性相对较差。一个线程的崩溃会导致整个程序崩溃。
2）临界资源的访问控制，在加大程序复杂性的同时，锁机制的引入会是严重降低
程序的性能。性能上可能会出现“辛辛苦苦好几年，一夜回到解放前”的情况。//当
多个线程需要同时访问临界资源时，需要通过锁机制来保持原子性，而锁机制会带来
巨大的开销。
